import torch
import trimesh
import numpy as np
from sklearn.neighbors import kneighbors_graph
from config.global_config import global_config


def convert_mesh_to_graph_data(vertices, faces):
    """
    given a mesh, convert it to a graph data.
    the feature of the graph data is the concatenation of vertex coordinates and vertex normals.
    """
    
    mesh = trimesh.Trimesh(vertices=vertices, faces=faces, process=False)
    # we update the vertices and faces to make sure they are consistent with other attributes, e.g., normals. 
    # this is necessary because trimesh may change the order/number of vertices and faces.
    vertices = mesh.vertices
    faces = mesh.faces
    edge_a = mesh.edges_unique
    edge_b = np.concatenate([edge_a[:, 1].reshape([-1, 1]), edge_a[:, 0].reshape([-1, 1])],
                            axis=1)  # [num_edges, 2]
    edges = np.concatenate([edge_a, edge_b], axis=0)  # [2 * num_edges, 2]
    edges = np.unique(edges, axis=0)  # [num_edges, 2]
    normals = mesh.vertex_normals
    x = np.concatenate([vertices, normals], axis=1)
    # convert to torch tensor
    x = torch.tensor(x, dtype=torch.float32)
    edges = torch.tensor(edges, dtype=torch.int64).t().contiguous()
    
    return Data(x=x,
                edge_index=edges,
    )



def convert_point_cloud_to_graph(vertices: np.array, normal: np.array=None, self_loop: bool = False, K: int = 10):
    """
    given a point cloud, return a graph generated by KNN.
    
    vertices: N x 3
    self_loop: add self loop or not
    K: the number of neighbors
    """
    
    assert vertices.shape[1] == 3, "vertices must be N x 3"
    assert K <= vertices.shape[0], "K must be less than the number of vertices"
    
    adj_matrix = kneighbors_graph(vertices, K, mode='connectivity', include_self=self_loop)
    # start_idx: [0, 0, 0,...(K times), 1, 1, 1,...(K times), ...]
    # end_idx: [(K vertices connected to 0), (K vertices connected to 1), ...]
    # note that kneighbors_graph will not account for self_loop
    start_idx, end_idx = adj_matrix.nonzero()
    edge_a = np.concatenate([start_idx.reshape([-1, 1]), end_idx.reshape([-1, 1])], axis=1)  # [num_edges, 2]
    edge_b = np.concatenate([edge_a[:, 1].reshape([-1, 1]), edge_a[:, 0].reshape([-1, 1])], axis=1)  # [num_edges, 2]
    #edges = edge_b
    edges = np.concatenate([edge_a, edge_b], axis=0)  # [2 * num_edges, 2]
    edges = np.unique(edges, axis=0)  # [num_edges, 2]
    
    if normal is not None:
        x = np.concatenate([vertices, normal], axis=1)
    else:
        x = vertices
    # convert x to torch.tensor
    x = torch.tensor(x, dtype=torch.float32)

    graph = Data(x=x, edge_index=torch.tensor(edges.T, dtype=torch.long))
    return graph
    
    
    
    


class Data:
    #@profile
    def __init__(self, x=None, edge_index=None, edge_attr=None, 
                 batch=None, edges_size_of_each_subgraph=None,
                 subgraphs: dict = None,
                 ):
        """
        a rewrite of torch_geometric.data.Data
        get rid of its self-aleck re-indexing
        :param edge_attr: the type of edges.
        :param subgraphs: dict, has 2 keys: "x", "edge_index". Each key corresponds to a list of torch.tensor. This is optional, providing this arg will acclerate the batch construction, but it will be OK if you don't provide it.
        """
        # basic attributes, convert them to float32
        self.x = x.to(torch.float32)
        self.edge_index = edge_index
        self.edge_attr = edge_attr
        
        # batching information
        self.batched_data = []
        if batch == None or batch.max() == 0:
            self.batch = torch.zeros([x.shape[0]], dtype=torch.int64)
        else:
            self.batch = batch.to(torch.int64)    # batch should be int64 for torch.scatter
            
            if subgraphs is not None:
                self.batched_data = []
                for i in range(batch.max().item()+1):
                    temp_graph = Data(x=subgraphs["x"][i], edge_index=subgraphs["edge_index"][i])
                    self.batched_data.append(temp_graph)
                return
            
            else:       # if subgraphs is None, we have to construct the batched_data by ourselves
                # TODO: optimize this part
                # generate a list of batch indices
                for i in range(batch.max().item()+1):
                    # find the index of the first vertex in batch i
                    first_idx = torch.where(batch == i)[0][0]
                    last_idx = torch.where(batch == i)[0][-1]
                    
                    # find all edges that connect vertices in batch i
                    edges_mask = torch.zeros([edge_index.shape[1]], dtype=torch.bool)
                    edges_size_of_each_subgraph = [0] + edges_size_of_each_subgraph
                    cumsum_edge_size = torch.cumsum(torch.tensor(edges_size_of_each_subgraph), dim=0)
                    edges_mask[cumsum_edge_size[i]:cumsum_edge_size[i+1]] = True
                            
                    edges_index_batch = edge_index[:, edges_mask]
                    #edges_attr_batch = edge_attr[edges_mask]
                    x_in_batch = x[first_idx:last_idx+1]
                # batch_debug = batch[first_idx:last_idx+1]
                    
                    temp_graph = Data(x=x_in_batch, edge_index=edges_index_batch, 
                                    #edge_attr=edges_attr_batch
                                    )
                    self.batched_data.append(temp_graph)
                

    def to(self, target):
        # trans data from gpu to cpu or vice versa
        self.x = self.x.to(target)
        self.edge_index = self.edge_index.to(target)
        if self.edge_attr != None:
            self.edge_attr = self.edge_attr.to(target)
        if self.batch != None:
            self.batch = self.batch.to(target)
        return self
    
    def __getitem__(self, index: int):
        # get a subgraph according to index and batch
        # slicing not supported
        assert type(index) == int, "index must be an int"
        assert index < self.batch.max().item() + 1, "index out of range"
        if self.batched_data.__len__() == 0 and index == 0:
            # construct a new Data object, so that the returned Data object can be modified without affecting the original Data object
            return Data(x=self.x, edge_index=self.edge_index, edge_attr=self.edge_attr, batch=self.batch)
        return self.batched_data[index]

        

    def cuda(self):
        return self.to("cuda")

    def cpu(self):
        return self.to("cpu")
    
    def clone(self):
        return Data(x=self.x.clone(), edge_index=self.edge_index.clone(), edge_attr=self.edge_attr.clone(), batch=self.batch.clone())
    

############################################
# utils
############################################


def convert_edge_format_to_adj_matrix(Data, edge_weight=None) -> torch.tensor:
    """
    Convert a pyg.data.Data's edge_index to an adjacency matrix. Only consider the edges that appear in data.edge_index.
    """
    edge_index = Data.edge_index
    num_verts = Data.x.shape[0]
    adj_matrix = torch.zeros([num_verts, num_verts])
    if edge_weight is None:
        edge_weight = torch.ones([edge_index.shape[1]])
    # TODO: optimize this part
    for i in range(edge_index.shape[1]):
        adj_matrix[edge_index[0, i], edge_index[1, i]] = edge_weight[i]
    return adj_matrix   



def convert_lap_matrix_to_edge_weight(data: Data, lap_matrix: torch.tensor) -> torch.tensor:
    """
    Convert a laplacian matrix to edge weights. Only consider the edges that appear in data.edge_index.
    """
    edge_weight = torch.zeros([data.edge_index.shape[1]])
    edge_index = data.edge_index
    for i in range(edge_index.shape[1]):
        edge_weight[i] = lap_matrix[edge_index[0, i], edge_index[1, i]]
  #  assert edge_weight[0,0] == 0, "edge_weight[0,0] should be 0 since no self-loop is considered."
    return edge_weight



############################################
# santiy check
############################################


def check_the_property_of_a_graph(data: Data):
    
    def check_if_a_graph_has_unconnected_vertices(Data: Data):
        """
        check if a graph has unconnected vertices.
        """
        from collections import defaultdict
        dict_of_edges = defaultdict(list)
        # construct a dict of edges
        for i in range(Data.edge_index.shape[1]):
            src = int(Data.edge_index[0, i])
            dst = int(Data.edge_index[1, i])
            dict_of_edges[src].append(dst)
        # check if there is any vertex that has no edge
        for i in range(Data.x.shape[0]):
            if i not in dict_of_edges.keys():
                return True
        return False
        
    def check_if_a_graph_has_single_direction_edges(Data: Data):
        """
        check if a graph has single direction edges.
        """
        from collections import defaultdict
        dict_of_edges = defaultdict(list)
        # construct a dict of edges
        for i in range(Data.edge_index.shape[1]):
            src = int(Data.edge_index[0, i])
            dst = int(Data.edge_index[1, i])
            dict_of_edges[src].append(dst)
        # for each edge, check if its reverse edge exists
        for i in range(Data.edge_index.shape[1]):
            src = int(Data.edge_index[0, i])
            dst = int(Data.edge_index[1, i])
            if src not in dict_of_edges[dst]:
                return True
        return False
            
            
    def check_if_a_graph_has_multi_edges(Data: Data):
        """
        given a graph, check if it has multi-edges.
        """
        from collections import defaultdict
        dict_of_edges = defaultdict(list)
        # construct a dict of edges
        for i in range(Data.edge_index.shape[1]):
            src = int(Data.edge_index[0, i])
            dst = int(Data.edge_index[1, i])
            if dst in dict_of_edges[src]:
                return True
            else:
                dict_of_edges[src].append(dst)
        return False


    def check_if_a_graph_has_self_loops(data: Data):
        """
        check if a graph has self loops.
        this function is a brute-force method, so do not use it for large graphs.
        """
        edges = data.edge_index
        for i in range(edges.shape[1]):
            if edges[0][i] == edges[1][i]:
                return True
        return False

    has_unconnected_vertices = check_if_a_graph_has_unconnected_vertices(data)
    has_self_loop = check_if_a_graph_has_self_loops(data)
    has_multi_edge = check_if_a_graph_has_multi_edges(data)
    has_single_direction_edges = check_if_a_graph_has_single_direction_edges(data)
    print("has_unconnected_vertices:", has_unconnected_vertices)
    print("has_self_loop:", has_self_loop)
    print("has_multi_edge:", has_multi_edge)
    print("has_single_direction_edges:", has_single_direction_edges)
    if has_self_loop or has_multi_edge or has_single_direction_edges:
        print("This graph is not a good graph!")
        return False

